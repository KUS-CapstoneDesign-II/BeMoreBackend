# 🎓 캡스톤디자인 제출용 README.md 작성 프롬프트

개발자 관점에서 기술적 깊이와 실용성을 강조한 캡스톤디자인 제출용 README를 생성하는 프롬프트입니다.

---

## 📝 메인 프롬프트 (복사해서 사용)

```markdown
캡스톤디자인 제출용 README.md를 개발자 관점으로 작성해 주세요.

## 프로젝트 기본 정보
- **프로젝트명**: [한글명] ([영문명])
- **개발 기간**: YYYY.MM ~ YYYY.MM
- **팀명**: [팀명]
- **소속**: [대학교] [학과]
- **과목**: 캡스톤디자인 II (YYYY-2학기)

## 팀 구성 및 역할
| 이름 | 역할 | 주요 담당 | GitHub |
|------|------|-----------|--------|
| [이름1] | Backend Lead | [담당 업무] | @username |
| [이름2] | Frontend Lead | [담당 업무] | @username |
| [이름3] | DevOps | [담당 업무] | @username |

## 프로젝트 개요
### 문제 정의
[해결하고자 하는 문제]

### 솔루션
[제안하는 해결 방법]

### 핵심 가치
1. [핵심 가치 1]
2. [핵심 가치 2]
3. [핵심 가치 3]

## 기술 스택 (상세)
### Backend
- **Runtime**: Node.js 18.x
- **Framework**: Express.js
- **Database**: PostgreSQL (Supabase)
- **AI/ML**: [사용한 AI 서비스]
- **WebSocket**: ws library
- **주요 라이브러리**: [라이브러리 목록]

### Frontend
- **Framework**: [React/Vue/Angular]
- **State Management**: [Redux/Vuex/etc]
- **Styling**: [Tailwind/MUI/etc]
- **주요 라이브러리**: [라이브러리 목록]

### DevOps & Infrastructure
- **Hosting**: [Render/AWS/etc]
- **CI/CD**: GitHub Actions
- **Monitoring**: [모니터링 도구]
- **Version Control**: Git + GitHub

## 시스템 아키텍처
[아키텍처 다이어그램 또는 상세 설명]
- 주요 컴포넌트 및 역할
- 데이터 흐름
- 외부 서비스 연동

## 핵심 기능 및 구현
### 기능 1: [기능명]
- **설명**: [기능 설명]
- **구현 방식**: [기술적 구현 방법]
- **기술적 도전**: [해결한 기술적 문제]

### 기능 2: [기능명]
[동일한 형식으로 반복]

## 개발 과정 및 방법론
- **개발 방법론**: [Agile/Scrum/etc]
- **협업 도구**: [Notion/Jira/etc]
- **코드 리뷰**: [리뷰 프로세스]
- **브랜치 전략**: [Git Flow/etc]

## 기술적 도전과제 및 해결
### 도전과제 1: [문제]
- **문제 상황**: [상세 설명]
- **해결 방법**: [기술적 해결 과정]
- **결과**: [개선 효과]

## 성능 최적화
- [최적화 항목 1]: [방법 및 결과]
- [최적화 항목 2]: [방법 및 결과]

## 코드 품질 관리
- **Linting**: [ESLint/Prettier]
- **Testing**: [Jest/Mocha/etc]
- **Code Coverage**: [커버리지 %]
- **Type Safety**: [TypeScript/etc]

## 설치 및 실행 가이드
[상세한 설치 및 실행 방법]

## API 문서
[주요 API 엔드포인트 문서]

## 향후 개선 계획
1. [개선 계획 1]
2. [개선 계획 2]

## 라이선스
[라이선스 정보]

## 작성 요구사항
1. **개발자 관점 강조**
   - 기술적 의사결정 이유 명확히
   - 구현 코드 예시 포함
   - 아키텍처 설계 근거 설명

2. **실용성 중시**
   - 재현 가능한 설치 가이드
   - 실제 실행 가능한 코드
   - 트러블슈팅 가이드

3. **깊이 있는 설명**
   - 단순 기능 나열이 아닌 구현 방법
   - 기술적 도전과제와 해결 과정
   - 성능 최적화 과정

4. **시각 자료 활용**
   - 시스템 아키텍처 다이어그램
   - 데이터 플로우 차트
   - 스크린샷/데모 영상 (선택)

5. **전문성 표현**
   - 정확한 기술 용어 사용
   - 버전 번호 명시
   - 코드 품질 관리 방법 설명
```

---

## 🎯 BeMore 프로젝트 맞춤 프롬프트

```markdown
BeMore Backend 프로젝트를 기반으로 캡스톤디자인 제출용 README.md를 작성해 주세요.

## 프로젝트 기본 정보
- **프로젝트명**: BeMore - AI 기반 심리 상담 지원 시스템
- **영문명**: BeMore - AI-Powered Mental Health Counseling Support System
- **개발 기간**: 2024.09 ~ 2025.11
- **팀명**: BeMore Team
- **소속**: 건국대학교 컴퓨터공학과
- **과목**: 캡스톤디자인 II (2024-2학기)
- **저장소**: https://github.com/KUS-CapstoneDesign-II/BeMoreBackend

## 팀 구성 및 역할
| 이름 | 역할 | 주요 담당 | 비고 |
|------|------|-----------|------|
| [이름1] | Backend Lead | 실시간 감정 분석, CBT 시스템 설계 | |
| [이름2] | Frontend Lead | UI/UX, 실시간 데이터 시각화 | |
| [이름3] | AI/ML | 멀티모달 감정 분석 모델 통합 | |

## 프로젝트 개요
### 문제 정의
- 심리 상담 접근성 부족 (비용, 시간, 지역적 제약)
- 상담사의 감정 파악 어려움 (비언어적 신호 놓침)
- 상담 품질의 일관성 부족

### 솔루션
실시간 **멀티모달 감정 분석**(얼굴/음성/대화)을 통한 **인지행동치료(CBT)** 자동 개입 시스템

### 핵심 가치
1. **실시간 감정 분석**: 얼굴 표정(478 landmarks) + 음성 활동(VAD) + 대화 내용 통합 분석
2. **자동 CBT 개입**: 10가지 인지 왜곡 유형 탐지 및 소크라테스식 질문 자동 생성
3. **세션 리포트**: AI 기반 종합 분석 리포트 자동 생성

## 기술 스택 (상세)
### Backend
- **Runtime**: Node.js 18.0.0
- **Framework**: Express.js 4.19.2
- **Database**: PostgreSQL 15 (Supabase)
- **AI/ML**:
  - Google Gemini API (감정 분석)
  - OpenAI Whisper API (STT)
  - Silero VAD (음성 활동 감지)
- **WebSocket**: ws 8.18.0 (3채널 실시간 통신)
- **주요 라이브러리**:
  - Sequelize 6.37.3 (ORM)
  - JWT (인증)
  - Zod (입력 검증)

### Frontend
- **Framework**: React 18.x + TypeScript
- **State Management**: Context API
- **UI Library**: Material-UI
- **WebSocket**: Native WebSocket API
- **Media Processing**: MediaPipe (얼굴 인식)

### DevOps & Infrastructure
- **Backend Hosting**: Render.com
- **Frontend Hosting**: Vercel
- **Database**: Supabase (PostgreSQL + Session Pooler)
- **CI/CD**: GitHub Actions
- **Monitoring**: Render Dashboard + Supabase Logs

## 시스템 아키텍처

### 전체 시스템 구조
```
[Client Browser]
    ↓ (WebSocket x3 + REST API)
[Express.js Server]
    ├─ WebSocket Server (3채널)
    │   ├─ Landmarks Channel (얼굴 표정)
    │   ├─ Voice Channel (음성 데이터)
    │   └─ Session Channel (제어)
    ├─ Core Services
    │   ├─ EmotionInferenceService (감정 추론)
    │   ├─ VADService (음성 활동 감지)
    │   ├─ STTService (음성→텍스트)
    │   ├─ CBT Modules (인지 왜곡 탐지)
    │   └─ ReportGenerator (리포트 생성)
    ├─ External APIs
    │   ├─ Google Gemini (감정 분석)
    │   ├─ OpenAI Whisper (STT)
    │   └─ Silero VAD (음성 활동)
    └─ Database (Supabase PostgreSQL)
```

### 데이터 처리 파이프라인
1. **Landmarks Channel**: 얼굴 표정 → Gemini API → 8가지 감정 분류
2. **Voice Channel**: 음성 → VAD → STT → 감정 분석
3. **통합 분석**: 얼굴 + 음성 + 대화 → CBT 분석 → 개입 생성
4. **세션 종료**: 전체 데이터 → 리포트 생성 → DB 저장

## 핵심 기능 및 구현

### 1. 멀티모달 감정 분석 시스템
**설명**: 얼굴 표정, 음성 활동, 대화 내용을 실시간으로 통합 분석

**구현 방식**:
```javascript
// EmotionInferenceService.js
class EmotionInferenceService {
  async analyzeExpression(landmarks) {
    // 478개 landmark → Gemini API → 감정 분류
    const prompt = this._buildPrompt(landmarks);
    const response = await geminiAPI.analyze(prompt);
    return {
      emotion: response.emotion,      // 8가지 감정
      confidence: response.confidence,
      valence: response.valence,      // V-A-D 모델
      arousal: response.arousal,
      dominance: response.dominance
    };
  }
}
```

**기술적 도전**:
- 문제: 3개 채널의 비동기 데이터 동기화
- 해결: 타임스탬프 기반 윈도우 매칭 (±500ms)
- 결과: 95% 이상의 동기화 정확도

### 2. CBT 인지 왜곡 탐지 시스템
**설명**: 10가지 인지 왜곡 유형 자동 탐지 및 치료적 개입 생성

**구현 방식**:
```javascript
// CognitiveDistortionDetector.js
class CognitiveDistortionDetector {
  detect(text, emotion, context) {
    const distortions = [];

    // 10가지 패턴 매칭
    for (const pattern of this.patterns) {
      if (pattern.match(text, emotion)) {
        distortions.push({
          type: pattern.type,
          name_ko: pattern.name_ko,
          severity: this._calculateSeverity(emotion, context),
          confidence: pattern.confidence,
          examples: pattern.extractExamples(text)
        });
      }
    }

    return distortions;
  }
}
```

**기술적 도전**:
- 문제: 한국어 감정 표현의 맥락적 이해
- 해결: Gemini Pro를 활용한 맥락 기반 분석
- 결과: 85% 이상의 탐지 정확도

### 3. 실시간 WebSocket 3채널 통신
**설명**: Landmarks, Voice, Session 3개 채널로 실시간 데이터 수신

**구현 방식**:
```javascript
// WebSocket 3채널 구조
wss.on('connection', (ws, req) => {
  const channel = parseChannel(req.url);

  if (channel === 'landmarks') {
    handleLandmarks(ws);      // 478 포인트/초
  } else if (channel === 'voice') {
    handleVoice(ws);          // 16kHz 오디오
  } else if (channel === 'session') {
    handleSession(ws);        // 제어 명령
  }
});
```

**기술적 도전**:
- 문제: 대용량 실시간 데이터 전송 (얼굴 landmarks)
- 해결: 바이너리 프로토콜 + 압축 + 샘플링 최적화
- 결과: 네트워크 대역폭 60% 절감

### 4. 자동 세션 리포트 생성
**설명**: 세션 종료 시 AI 기반 종합 분석 리포트 자동 생성

**구현 방식**:
```javascript
// SessionReportGenerator.js
async generateReport(sessionData) {
  return {
    emotionTimeline: this._analyzeEmotions(sessionData),
    vadVector: this._calculateVAD(sessionData),
    cbtFindings: this._generateCBTFindings(sessionData),
    cbtSummary: {
      totalDistortions: count,
      mostCommon: mostFrequent,
      interventions: generatedInterventions
    },
    recommendations: this._generateRecommendations()
  };
}
```

**기술적 도전**:
- 문제: 대용량 세션 데이터의 효율적 처리
- 해결: 스트리밍 방식 분석 + 점진적 리포트 생성
- 결과: 리포트 생성 시간 < 2초

## 개발 과정 및 방법론

### 개발 방법론
- **Agile**: 2주 스프린트
- **일일 스탠드업**: 매일 오전 10시 (Discord)
- **주간 회고**: 매주 금요일

### 협업 도구
- **코드 관리**: GitHub (Git Flow)
- **문서화**: Notion
- **커뮤니케이션**: Discord, Slack

### 코드 리뷰 프로세스
1. Feature 브랜치에서 개발
2. PR 생성 (최소 1명 리뷰어)
3. CI/CD 자동 테스트 통과
4. 리뷰 승인 후 Merge

### 브랜치 전략 (Git Flow)
```
main          ──────●─────●─────●  (프로덕션)
               ╱      ╲   ╱      ╲
develop  ──●──●────●──●─●────●───●  (개발)
            ╱  ╲      ╱  ╲      ╱
feature   ●────●    ●────●    ●     (기능)
```

## 기술적 도전과제 및 해결

### 도전과제 1: Supabase IPv6/IPv4 호환성
**문제 상황**:
- Render.com은 IPv4 전용 네트워크
- Supabase Direct Connection은 IPv6
- DB 연결 불가 (`getaddrinfo ENOTFOUND`)

**해결 방법**:
```javascript
// Before (실패)
DATABASE_URL=postgresql://user:pass@db.xxx.supabase.co:5432/postgres

// After (성공)
DATABASE_URL=postgresql://user:pass@aws-0-region.pooler.supabase.com:5432/postgres
```
- Supabase Session Pooler (IPv4) 사용
- Connection pooling으로 성능도 개선

**결과**: DB 연결 성공 + 10% 성능 향상

### 도전과제 2: Gemini API 타임아웃 문제
**문제 상황**:
- 초기 타임아웃: 30초
- 복잡한 감정 분석 시 타임아웃 발생률 15%

**해결 방법**:
```javascript
// 타임아웃 최적화
const geminiConfig = {
  timeout: 45000,              // 30s → 45s
  retry: 3,                    // 재시도 추가
  fallback: useLocalInference  // 폴백 모델
};
```

**결과**: 타임아웃 발생률 15% → 2% 감소

### 도전과제 3: 실시간 데이터 동기화
**문제 상황**:
- 3개 채널의 데이터 도착 시간 불일치
- 감정 분석의 정확도 저하

**해결 방법**:
```javascript
// 타임스탬프 기반 윈도우 매칭
class DataSynchronizer {
  matchDataPoints(landmarks, voice, timestamp) {
    const window = 500; // ±500ms

    return {
      landmarks: findNearest(landmarks, timestamp, window),
      voice: findNearest(voice, timestamp, window),
      confidence: calculateSyncConfidence()
    };
  }
}
```

**결과**: 동기화 정확도 70% → 95% 향상

## 성능 최적화

### 1. 데이터베이스 쿼리 최적화
- **문제**: 세션 조회 시 N+1 쿼리 발생
- **해결**: Sequelize `include` 옵션으로 Eager Loading
- **결과**: 쿼리 시간 500ms → 50ms (90% 감소)

### 2. WebSocket 데이터 압축
- **문제**: 얼굴 landmarks 데이터 크기 (478 포인트 × 3 좌표)
- **해결**: Float64 → Float32 + 델타 인코딩
- **결과**: 데이터 크기 60% 감소

### 3. CBT 분석 캐싱
- **문제**: 동일한 텍스트 패턴 반복 분석
- **해결**: LRU 캐시 (최대 100개 항목)
- **결과**: 분석 시간 30% 감소

### 4. 리포트 생성 최적화
- **문제**: 대용량 세션 데이터 메모리 문제
- **해결**: 스트리밍 방식 처리
- **결과**: 메모리 사용량 70% 감소

## 코드 품질 관리

### Linting & Formatting
- **ESLint**: Airbnb JavaScript Style Guide
- **Prettier**: 코드 포맷팅 자동화
- **Pre-commit Hook**: Husky로 커밋 전 자동 검사

### Testing
- **Unit Tests**: Jest (services/, utils/)
- **Integration Tests**: Supertest (API endpoints)
- **Test Coverage**: 현재 65% (목표: 80%)

### Type Safety
- **Zod**: Runtime 타입 검증
- **TypeScript**: 프론트엔드 100% 타입 안정성

### Code Review
- **필수 리뷰**: 모든 PR에 최소 1명 리뷰어
- **CI 통과**: 테스트 + Lint 자동 검사
- **문서화**: 주요 기능에 JSDoc 주석

## 설치 및 실행 가이드

### 사전 요구사항
```bash
Node.js >= 18.0.0
PostgreSQL >= 15 (또는 Supabase 계정)
```

### 환경 변수 설정
```bash
cp .env.example .env

# .env 파일 편집
DATABASE_URL=postgresql://...
GEMINI_API_KEY=your-key
OPENAI_API_KEY=your-key
JWT_SECRET=your-secret
```

### 로컬 실행
```bash
# 1. 의존성 설치
npm install

# 2. 데이터베이스 초기화
npm run db:init

# 3. 개발 서버 실행
npm run dev
```

### 프로덕션 배포
```bash
# 1. 빌드
npm run build

# 2. 프로덕션 실행
npm start
```

### Health Check
```bash
curl http://localhost:3000/health

# 예상 응답
{
  "status": "ok",
  "version": "1.3.0",
  "database": "connected"
}
```

## API 문서

### 인증
```http
POST /api/auth/signup
POST /api/auth/login
POST /api/auth/refresh
```

### 세션 관리
```http
POST /api/session/start
PUT /api/session/:id/pause
PUT /api/session/:id/resume
PUT /api/session/:id/end
```

### 리포트 조회
```http
GET /api/session/:id/report
GET /api/session/:id/summary
```

### WebSocket 연결
```javascript
// Landmarks Channel
ws://localhost:3000/ws/landmarks?sessionId=xxx

// Voice Channel
ws://localhost:3000/ws/voice?sessionId=xxx

// Session Channel
ws://localhost:3000/ws/session?userId=xxx
```

## 프로젝트 성과

### 정량적 성과
- **코드 라인**: Backend 15,000+ lines
- **API 엔드포인트**: 20+개
- **테스트 커버리지**: 65%
- **WebSocket 동시 접속**: 100+명 지원
- **실시간 분석 지연**: < 500ms
- **리포트 생성 시간**: < 2초

### 정성적 성과
- 실시간 멀티모달 감정 분석 시스템 구현
- 자동 CBT 개입 시스템 개발
- 확장 가능한 마이크로서비스 아키텍처 설계
- CI/CD 파이프라인 구축

## 향후 개선 계획

### 단기 (1-3개월)
1. **테스트 커버리지 향상**: 65% → 90%
2. **STT 응답 시간 개선**: 5초 → 3초 이내
3. **에러 로깅 시스템**: Sentry 통합

### 중기 (3-6개월)
1. **머신러닝 모델 자체 학습**: 감정 분석 정확도 향상
2. **다국어 지원**: 영어, 일본어 추가
3. **모바일 앱**: React Native 개발

### 장기 (6-12개월)
1. **실시간 음성 변조**: 프라이버시 보호
2. **VR 통합**: 메타버스 상담실
3. **블록체인 기반 데이터 보안**

## 프로젝트 문서

### 개발 문서
- [API 상세 문서](./README.md)
- [데이터베이스 스키마](./schema/init.sql)
- [배포 가이드](./README.md#-production-deployment-guide)

### 제출 문서
- [최종 보고서](./docs/capstone/)
- [발표 자료](./docs/capstone/)
- [데모 영상](./docs/capstone/)

## 라이선스
ISC License

## 팀 연락처
- **GitHub**: https://github.com/KUS-CapstoneDesign-II/BeMoreBackend
- **이메일**: [팀 대표 이메일]

---

**작성 일시**: 2025-11-18
**프로젝트 버전**: v1.3.0
**문서 버전**: 1.0.0
```

---

## 🎨 작성 스타일 가이드

### 1. 개발자 관점 강조
```markdown
❌ 나쁜 예시:
"감정 분석 기능을 구현했습니다."

✅ 좋은 예시:
"Google Gemini Pro API를 활용하여 478개 얼굴 landmarks를
실시간으로 분석하고, V-A-D 모델로 감정을 정량화했습니다.
타임아웃 문제를 해결하기 위해 재시도 로직과 폴백 모델을 구현하여
타임아웃 발생률을 15%에서 2%로 감소시켰습니다."
```

### 2. 코드 예시 포함
```markdown
❌ 나쁜 예시:
"데이터베이스 연결을 최적화했습니다."

✅ 좋은 예시:
"Sequelize ORM의 include 옵션으로 N+1 쿼리 문제를 해결했습니다.

// Before
const sessions = await Session.findAll();
for (let session of sessions) {
  session.user = await User.findByPk(session.userId); // N+1!
}

// After
const sessions = await Session.findAll({
  include: [{ model: User }]  // Single query
});

결과: 쿼리 시간 500ms → 50ms (90% 감소)"
```

### 3. 기술적 도전과제 명확히
```markdown
구조:
1. 문제 상황 (구체적 증상, 에러 메시지)
2. 원인 분석 (기술적 근본 원인)
3. 해결 방법 (구현 코드, 설정 변경)
4. 결과 (정량적 개선 효과)
```

### 4. 다이어그램 활용
```markdown
# Mermaid를 활용한 시스템 아키텍처
```mermaid
graph TB
    Client[Client Browser]
    WS[WebSocket Server]
    API[REST API]
    DB[(Database)]

    Client -->|WebSocket| WS
    Client -->|HTTP| API
    WS --> DB
    API --> DB
```
```

### 5. 정량적 지표 제시
```markdown
❌ 나쁜 예시:
"성능이 개선되었습니다."

✅ 좋은 예시:
"응답 시간: 500ms → 50ms (90% 감소)
메모리 사용량: 500MB → 150MB (70% 감소)
에러율: 15% → 2% (87% 감소)"
```

---

## 📊 체크리스트

### 필수 포함 항목
- [ ] 프로젝트 개요 (문제 정의 + 솔루션)
- [ ] 팀 구성 및 역할 (구체적 담당 업무)
- [ ] 기술 스택 (상세 버전 명시)
- [ ] 시스템 아키텍처 (다이어그램)
- [ ] 핵심 기능 구현 (코드 예시 포함)
- [ ] 기술적 도전과제 및 해결 (3개 이상)
- [ ] 성능 최적화 과정
- [ ] 설치 및 실행 가이드 (재현 가능)
- [ ] API 문서
- [ ] 코드 품질 관리 방법

### 선택 포함 항목
- [ ] 데모 영상/스크린샷
- [ ] 성능 벤치마크 결과
- [ ] 테스트 커버리지 리포트
- [ ] 향후 개선 계획
- [ ] 프로젝트 회고

### 작성 품질 체크
- [ ] 모든 코드 예시가 실제 실행 가능한가?
- [ ] 기술적 의사결정 이유가 명확한가?
- [ ] 정량적 지표가 포함되어 있는가?
- [ ] 재현 가능한 설치 가이드인가?
- [ ] 전문 용어 사용이 정확한가?

---

## 💡 작성 팁

### 1. 차별화 포인트 강조
- 다른 프로젝트와 차별되는 기술적 혁신
- 해결한 고난도 기술적 문제
- 독창적인 아키텍처 설계

### 2. 실제 구현 증명
- 실행 가능한 코드 예시
- 배포된 서비스 URL
- GitHub 저장소 링크

### 3. 개발 과정 투명성
- 시행착오 과정 공유
- 기술적 의사결정 이유
- 팀 협업 과정

### 4. 전문성 표현
- 정확한 기술 용어
- 업계 표준 방법론
- 최신 기술 스택

---

## 🎓 평가 관점 대응

### 기술적 완성도 (30%)
→ 시스템 아키텍처, 핵심 기능 구현 상세 설명

### 창의성/혁신성 (25%)
→ 멀티모달 분석, 자동 CBT 개입의 독창성 강조

### 실용성/효과성 (20%)
→ 성능 지표, 사용자 시나리오, 실제 배포 증명

### 개발 과정 (15%)
→ 협업 방법론, 코드 품질 관리, 문제 해결 과정

### 문서화 (10%)
→ 상세한 설치 가이드, API 문서, 코드 주석

---

**프롬프트 버전**: 1.0.0
**작성일**: 2025-11-18
**대상**: 캡스톤디자인 제출용
**관점**: 개발자 중심 기술 문서
