<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <title>BeMore - Emotion Analyzer Demo</title>
  <style>
    video,
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      transform: scaleX(-1);
    }

    #status {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px;
      border-radius: 8px;
      font-family: sans-serif;
      z-index: 10;
      max-width: 400px;
    }

    #controls {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px;
      border-radius: 8px;
      font-family: sans-serif;
      z-index: 10;
    }

    button {
      margin: 5px;
      padding: 10px 15px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      font-size: 14px;
    }

    button:hover {
      opacity: 0.8;
    }

    .btn-pause {
      background: #ff9800;
      color: white;
    }

    .btn-resume {
      background: #4caf50;
      color: white;
    }

    .btn-end {
      background: #f44336;
      color: white;
    }
  </style>
</head>

<body>
  <div id="status">
    <div>🎥 초기화 중...</div>
    <div id="session-info"></div>
    <div id="emotion-info"></div>
  </div>

  <div id="controls">
    <button class="btn-pause" onclick="pauseSession()">⏸️ 일시정지</button>
    <button class="btn-resume" onclick="resumeSession()">▶️ 재개</button>
    <button class="btn-end" onclick="endSession()">⏹️ 종료</button>
  </div>

  <video id="input_video" autoplay playsinline></video>
  <canvas id="output_canvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

  <script>
    const statusDiv = document.getElementById("status");
    const sessionInfo = document.getElementById("session-info");
    const emotionInfo = document.getElementById("emotion-info");
    const videoElement = document.getElementById("input_video");
    const canvasElement = document.getElementById("output_canvas");
    const canvasCtx = canvasElement.getContext("2d");

    // ====== 주요 랜드마크 인덱스 (468개 → 68개 중간 정밀도) ======
    // CBT 인지 왜곡 탐지에 최적화된 68개 포인트
    const KEY_LANDMARKS = {
      // 눈 영역 (20개) - 눈 뜨기, 눈가 주름 (Duchenne marker)
      eyes: [
        33, 133, 160, 144, 158, 153, 145, 159, 246, 163,  // 왼쪽 눈
        362, 263, 387, 373, 385, 380, 374, 386, 466, 390  // 오른쪽 눈
      ],

      // 눈썹 영역 (10개) - AU1, AU2, AU4 (슬픔, 분노, 걱정)
      eyebrows: [
        70, 63, 105, 66, 107,   // 왼쪽 눈썹
        300, 293, 334, 296, 336 // 오른쪽 눈썹
      ],

      // 입 영역 (20개) - AU12, AU15, AU17, AU20 (행복, 슬픔, 분노)
      mouth: [
        61, 291, 0, 17, 37, 39, 40, 185, 409, 267,
        269, 270, 78, 308, 324, 318, 402, 317, 14, 87
      ],

      // 코 영역 (8개) - AU9 (코 주름, 혐오 감정)
      nose: [1, 2, 98, 327, 4, 5, 195, 197],

      // 얼굴 윤곽 (10개) - 얼굴 방향, 각도
      contour: [10, 338, 297, 332, 284, 251, 389, 356, 454, 234]
    };

    // 랜드마크 압축 함수 (85% 대역폭 절감, 정확도 90%)
    function compressLandmarks(landmarks) {
      const face = landmarks[0];
      const compressed = {
        eyes: [],
        eyebrows: [],
        mouth: [],
        nose: [],
        contour: []
      };

      // 각 영역별로 좌표 추출
      for (const [region, indices] of Object.entries(KEY_LANDMARKS)) {
        compressed[region] = indices.map(index => ({
          x: face[index].x,
          y: face[index].y,
          z: face[index].z
        }));
      }

      return compressed;
    }

    // ====== 세션 관리 ======
    let sessionId = null;
    let landmarksWs = null;
    let voiceWs = null;
    let sessionWs = null;

    // 세션 시작
    async function startSession() {
      try {
        const response = await fetch('/api/session/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            userId: 'demo_user_001',
            counselorId: 'demo_counselor_001'
          })
        });

        const result = await response.json();
        if (!result.success) {
          throw new Error(result.error.message);
        }

        sessionId = result.data.sessionId;
        sessionInfo.innerHTML = `<b>세션 ID:</b> ${sessionId}<br><b>상태:</b> active`;

        // WebSocket 3채널 연결
        connectWebSockets(result.data.wsUrls);

        return sessionId;
      } catch (error) {
        console.error('세션 시작 오류:', error);
        statusDiv.textContent = `❌ 세션 시작 실패: ${error.message}`;
        throw error;
      }
    }

    // WebSocket 3채널 연결
    function connectWebSockets(wsUrls) {
      // 1. Landmarks 채널
      landmarksWs = new WebSocket(wsUrls.landmarks);
      landmarksWs.onopen = () => console.log('✅ Landmarks 채널 연결');
      landmarksWs.onmessage = (event) => {
        const message = JSON.parse(event.data);
        if (message.type === 'emotion_update') {
          emotionInfo.innerHTML = `<b>😃 감정:</b> ${message.data.emotion}<br><b>프레임:</b> ${message.data.frameCount}`;
        }
      };

      // 2. Voice 채널
      voiceWs = new WebSocket(wsUrls.voice);
      voiceWs.onopen = () => console.log('✅ Voice 채널 연결');
      voiceWs.onmessage = (event) => {
        const message = JSON.parse(event.data);
        if (message.type === 'stt_received') {
          console.log('✅ STT 수신 확인');
        }
      };

      // 3. Session 채널
      sessionWs = new WebSocket(wsUrls.session);
      sessionWs.onopen = () => console.log('✅ Session 채널 연결');
      sessionWs.onmessage = (event) => {
        const message = JSON.parse(event.data);
        console.log('Session 메시지:', message);

        if (message.type === 'status_update') {
          sessionInfo.innerHTML = `<b>세션 ID:</b> ${sessionId}<br><b>상태:</b> ${message.data.status}<br><b>감정 수:</b> ${message.data.emotionCount}`;
        }
      };
    }

    // 세션 제어 함수들
    async function pauseSession() {
      if (!sessionId) return;
      const res = await fetch(`/api/session/${sessionId}/pause`, { method: 'POST' });
      const data = await res.json();
      console.log('⏸️ 일시정지:', data);
    }

    async function resumeSession() {
      if (!sessionId) return;
      const res = await fetch(`/api/session/${sessionId}/resume`, { method: 'POST' });
      const data = await res.json();
      console.log('▶️ 재개:', data);
    }

    async function endSession() {
      if (!sessionId) return;


      // 1. STT 전송 반복 종료
      if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
      }

      // 2. MediaRecorder 정지
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }

      // 3. 마이크 스트림 트랙 중지
      if (audioStream) {
        audioStream.getTracks().forEach(track => track.stop());
        audioStream = null;
      }



      const res = await fetch(`/api/session/${sessionId}/end`, { method: 'POST' });
      const data = await res.json();
      console.log('✅ 종료:', data);

      // WebSocket 연결 종료
      if (landmarksWs) landmarksWs.close();
      if (voiceWs) voiceWs.close();
      if (sessionWs) sessionWs.close();
    }

    // ====== MediaPipe FaceMesh 설정 ======
    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });

    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    let frameCount = 0;
    faceMesh.onResults((results) => {
      canvasElement.width = videoElement.videoWidth;
      canvasElement.height = videoElement.videoHeight;
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      if (results.multiFaceLandmarks) {
        // 전체 랜드마크 시각화
        for (const landmarks of results.multiFaceLandmarks) {
          for (const point of landmarks) {
            const x = point.x * canvasElement.width;
            const y = point.y * canvasElement.height;
            canvasCtx.beginPath();
            canvasCtx.arc(x, y, 1.5, 0, 2 * Math.PI);
            canvasCtx.fillStyle = "red";
            canvasCtx.fill();
          }
        }

        // 압축된 데이터 전송 (30fps → 10fps로 전송)
        frameCount++;
        if (frameCount % 3 === 0 && landmarksWs && landmarksWs.readyState === WebSocket.OPEN) {
          const compressed = compressLandmarks(results.multiFaceLandmarks);
          landmarksWs.send(JSON.stringify({
            type: 'landmarks',
            data: compressed
          }));
        }
      }
    });

    // ====== 카메라 시작 ======
    const camera = new Camera(videoElement, {
      onFrame: async () => await faceMesh.send({ image: videoElement }),
      width: 640,
      height: 480
    });

    // ====== 마이크 녹음 및 STT 전송 ======
    let mediaRecorder;
    let audioChunks = [];
    let audioStream;
    let recordingInterval;

    const initAndStartRecorder = (stream) => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }

      audioChunks = [];
      mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm; codecs=opus" });

      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) {
          audioChunks.push(e.data);
        }
      };

      mediaRecorder.start();
    };

    async function startMicRecording() {
      audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      initAndStartRecorder(audioStream);

      recordingInterval = setInterval(async () => {
        if (mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
        } else {
          initAndStartRecorder(audioStream);
          return;
        }

        if (audioChunks.length === 0) {
          initAndStartRecorder(audioStream);
          return;
        }

        const blob = new Blob(audioChunks, { type: "audio/webm; codecs=opus" });

        if (blob.size < 500) {
          initAndStartRecorder(audioStream);
          return;
        }

        const formData = new FormData();
        formData.append("audio", blob, `speech_${Date.now()}.webm`);
        initAndStartRecorder(audioStream);

        try {
          const res = await fetch("/api/stt/transcribe", {
            method: "POST",
            body: formData
          });
          const data = await res.json();
          console.log("🗣️ STT 결과:", data.text);

          // Voice 채널로 STT 텍스트 전송
          if (voiceWs && voiceWs.readyState === WebSocket.OPEN && data.text) {
            voiceWs.send(JSON.stringify({
              type: 'stt_text',
              data: { text: data.text }
            }));
          }
        } catch (err) {
          console.error("STT 업로드 실패:", err);
        }
      }, 5000);

      statusDiv.textContent = "🎤 음성 녹음 중 + 얼굴 추적 중";
    }

    // ====== 앱 초기화 ======
    async function initApp() {
      try {
        // 1. 세션 시작
        await startSession();

        // 2. 카메라 시작
        camera.start();

        // 3. 마이크 시작
        await startMicRecording();

        statusDiv.innerHTML = '<div>✅ 모든 시스템 초기화 완료</div>';
      } catch (error) {
        statusDiv.innerHTML = `<div>❌ 초기화 실패: ${error.message}</div>`;
      }
    }

    // 앱 시작
    initApp();

    // 페이지를 떠날 때 정리
    window.onbeforeunload = () => {
      clearInterval(recordingInterval);
      if (mediaRecorder && mediaRecorder.stream) {
        mediaRecorder.stream.getTracks().forEach(track => track.stop());
      }
      endSession();
    };
  </script>
</body>

</html>