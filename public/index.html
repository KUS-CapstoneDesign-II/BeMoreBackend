<!DOCTYPE html>
<html lang="ko">


<head>

  <meta charset="UTF-8" />
  <title>Emotion Analyzer Demo</title>
  <style>
    video,
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      transform: scaleX(-1);
    }

    #status {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
      z-index: 10;
    }
  </style>

</head>


<body>
  <div id="status">🎥 초기화 중...</div>
  <!-- 종료 버튼 추가 -->
  <button id="stopBtn" style="position: fixed; top: 10px; right: 10px; z-index: 11; padding: 8px 12px;">종료</button>
  <video id="input_video" autoplay playsinline></video>
  <canvas id="output_canvas"></canvas>


  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>


  <script>
    const statusDiv = document.getElementById("status");
    const videoElement = document.getElementById("input_video");
    const canvasElement = document.getElementById("output_canvas");
    const canvasCtx = canvasElement.getContext("2d");

    // ====== WebSocket 연결 ======
    const ws = new WebSocket("ws://localhost:8000");
    ws.onopen = () => (statusDiv.textContent = "✅ WebSocket 연결 완료");
    ws.onmessage = (msg) => {
      try {
        const data = JSON.parse(msg.data);
        if (data.type === 'analysis_result' || data.emotion) {
          statusDiv.textContent = `😃 감정: ${data.emotion || data.emotion}`;
        } else if (data.type === 'final_analysis') {
          // 최종 분석 결과 표시
          showFinalAnalysis(data);
        } else if (data.type === 'stop_refused') {
          alert('종료 거부: ' + (data.reason || '세션이 충분하지 않습니다.'));
        }
      } catch (e) { console.error('ws message parse error', e); }
    };

    // ====== Mediapipe FaceMesh 설정 ======
    const faceMesh = new FaceMesh({
      locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`,
    });

    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });

    let frameCount = 0;
    faceMesh.onResults((results) => {
      canvasElement.width = videoElement.videoWidth;
      canvasElement.height = videoElement.videoHeight;
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(
        results.image,
        0,
        0,
        canvasElement.width,
        canvasElement.height
      );

      if (results.multiFaceLandmarks) {
        for (const landmarks of results.multiFaceLandmarks) {
          for (const point of landmarks) {
            const x = point.x * canvasElement.width;
            const y = point.y * canvasElement.height;
            canvasCtx.beginPath();
            canvasCtx.arc(x, y, 1.5, 0, 2 * Math.PI);
            canvasCtx.fillStyle = "red";
            canvasCtx.fill();
          }
        }

        frameCount++;
        if (frameCount % 3 === 0 && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify(results.multiFaceLandmarks));
        }
      }
    });

    // ====== 카메라 시작 ======
    const camera = new Camera(videoElement, {
      onFrame: async () => await faceMesh.send({ image: videoElement }),
      width: 640,
      height: 480,
    });
    camera.start();

    // ====== 마이크 녹음 및 STT 전송 (수정된 안정적인 로직) ======
    let mediaRecorder;
    let audioChunks = [];
    let audioStream;
    let recordingInterval;

    // MediaRecorder를 초기화하고 시작하는 헬퍼 함수
    const initAndStartRecorder = (stream) => {
      // 이전 인스턴스가 있다면 중지하고 정리 (안전 조치)
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }

      audioChunks = []; // 데이터 버퍼 초기화

      // 새로운 MediaRecorder 인스턴스 생성
      mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm; codecs=opus" });

      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) {
          audioChunks.push(e.data);
        }
      };

      mediaRecorder.start(); // 즉시 녹음 시작
    };

    async function startMicRecording() {
      audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });

      // 최초 녹음 시작
      initAndStartRecorder(audioStream);

      // 5초 단위로 자동 전송 (중지 -> 전송 -> 재시작)
      recordingInterval = setInterval(async () => {

        // 1. 녹음 중지: ondataavailable 이벤트를 강제하여 청크를 최종 확보
        if (mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
        } else {
          // 이미 멈춰있다면 (예: 중지 이벤트 처리 중) 재시작만 하고 데이터 전송은 스킵
          initAndStartRecorder(audioStream);
          return;
        }

        // ondataavailable이 비동기적으로 실행된 후, audioChunks가 채워지기를 기다림
        // 데이터가 준비될 때까지 잠시 대기 (setTimeout 대신 다음 루프에서 처리)
        // 즉시 실행될 경우, audioChunks.length === 0 일 수 있으므로 방어 로직 추가

        // 2. 데이터 처리 및 전송
        // ondataavailable이 완전히 실행되기를 기다리기 위해 잠시 딜레이를 주거나,
        // 다음 인터벌 루프에서 처리하는 것이 일반적입니다. 여기서는 다음 루프를 위해
        // 바로 initAndStartRecorder(audioStream)를 호출하지 않고, 현재 확보된 청크만 확인합니다.

        if (audioChunks.length === 0) {
          // 데이터가 확보되지 않았다면 다음 루프에서 재시도 (중지/재시작은 initAndStartRecorder에서 처리됨)
          initAndStartRecorder(audioStream);
          return;
        }

        const blob = new Blob(audioChunks, { type: "audio/webm; codecs=opus" });
        // audioChunks = []; // 버퍼는 initAndStartRecorder에서 초기화됨

        if (blob.size < 500) {
          initAndStartRecorder(audioStream); // 작은 파일 무시 후 재시작
          return;
        }

        const formData = new FormData();
        formData.append("audio", blob, `speech_${Date.now()}.webm`);

        // 3. 녹음 재시작 (전송 전에 시작하여 빈 시간 최소화)
        initAndStartRecorder(audioStream);

        // 4. STT 전송
        try {
          const res = await fetch("/api/transcribe", {
            method: "POST",
            body: formData,
          });
          const data = await res.json();
          console.log("🗣️ STT 결과:", data.text);
        } catch (err) {
          console.error("STT 업로드 실패:", err);
        }

      }, 5000);

      statusDiv.textContent = "🎤 음성 녹음 중 + 얼굴 추적 중";
    }

    startMicRecording().catch((err) => {
      statusDiv.textContent = "🚫 마이크 접근 실패: " + err.message;
    });

    // ====== 종료 버튼 처리 (서버 확인 후 로컬 정지)
    const stopBtn = document.getElementById('stopBtn');
    stopBtn.addEventListener('click', () => {
      if (ws.readyState !== WebSocket.OPEN) {
        alert('서버와 연결되어 있지 않습니다.');
        return;
      }

      // 서버에 stop 요청 전송
      ws.send(JSON.stringify({ type: 'control', action: 'stop' }));
      statusDiv.textContent = '요청 중... 서버 응답 대기';
    });

    // 최종 분석 UI 표시 함수 (종합 분석 페이지)
    function showFinalAnalysis(data) {
      // 전체 화면 분석 패널 생성
      const panel = document.createElement('div');
      panel.id = 'analysisPanel';
      panel.style.position = 'fixed';
      panel.style.left = '0';
      panel.style.top = '0';
      panel.style.width = '100%';
      panel.style.height = '100%';
      panel.style.background = '#f6f8fa';
      panel.style.zIndex = '1000';
      panel.style.overflow = 'auto';
      panel.style.fontFamily = 'sans-serif';

      // 내부 스타일
      const container = document.createElement('div');
      container.style.maxWidth = '1000px';
      container.style.margin = '40px auto';
      container.style.background = 'white';
      container.style.borderRadius = '10px';
      container.style.boxShadow = '0 8px 24px rgba(0,0,0,0.12)';
      container.style.padding = '24px';

      const header = document.createElement('div');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';

      const title = document.createElement('h2');
      title.textContent = '종합 감정 분석 결과';

      const controls = document.createElement('div');
      controls.style.display = 'flex';
      controls.style.gap = '8px';

      const downloadBtn = document.createElement('button');
      downloadBtn.textContent = '결과 다운로드';
      downloadBtn.addEventListener('click', () => downloadReport(data));

      const restartBtn = document.createElement('button');
      restartBtn.textContent = '다시 시작';
      restartBtn.addEventListener('click', () => {
        // 패널 제거 후 리소스 재시작
        document.body.removeChild(panel);
        try { camera.start(); } catch (e) { /* noop */ }
        // 재녹음 시작
        startMicRecording().catch(err => console.warn('재시작 중 마이크 오류', err));
        frameCount = 0;
        statusDiv.textContent = '🎤 음성 녹음 중 + 얼굴 추적 중';
      });

      const closeBtn = document.createElement('button');
      closeBtn.textContent = '닫기';
      closeBtn.addEventListener('click', () => {
        document.body.removeChild(panel);
      });

      controls.appendChild(downloadBtn);
      controls.appendChild(restartBtn);
      controls.appendChild(closeBtn);

      header.appendChild(title);
      header.appendChild(controls);

      // 요약 섹션
      const summary = document.createElement('div');
      summary.style.display = 'grid';
      summary.style.gridTemplateColumns = '1fr 1fr';
      summary.style.gap = '12px';
      summary.style.marginTop = '16px';

      const emotionCard = document.createElement('div');
      emotionCard.style.padding = '16px';
      emotionCard.style.border = '1px solid #e6e9ee';
      emotionCard.style.borderRadius = '8px';
      const emotionTitle = document.createElement('h3');
      emotionTitle.textContent = '감정 요약';
      const emotionText = document.createElement('p');
      emotionText.style.fontSize = '20px';
      emotionText.style.fontWeight = '600';
      emotionText.textContent = data.emotion || '알 수 없음';
      // 상세 리포트(가능하면) 표시
      if (data.detailed_report && data.detailed_report.report) {
        const dr = data.detailed_report.report;
        const drBox = document.createElement('div');
        drBox.style.marginTop = '8px';
        drBox.innerHTML = `<strong>신뢰도:</strong> ${dr.confidence ?? '-'}<br/><strong>추천:</strong> ${Array.isArray(dr.recommendation) ? dr.recommendation.join('<br/>') : (dr.recommendation || '-')}`;
        emotionCard.appendChild(drBox);
      }
      emotionCard.appendChild(emotionTitle);
      emotionCard.appendChild(emotionText);

      const statsCard = document.createElement('div');
      statsCard.style.padding = '16px';
      statsCard.style.border = '1px solid #e6e9ee';
      statsCard.style.borderRadius = '8px';
      const statsTitle = document.createElement('h3');
      statsTitle.textContent = '통계';
      const statsBody = document.createElement('div');
      statsBody.innerHTML = `<p>프레임 수: ${data.frames_count || 0}</p><p>분석 시각: ${data.timestamp || ''}</p>`;
      statsCard.appendChild(statsTitle);
      statsCard.appendChild(statsBody);

      summary.appendChild(emotionCard);
      summary.appendChild(statsCard);

      // STT 섹션
      const sttSection = document.createElement('div');
      sttSection.style.marginTop = '16px';
      const sttTitle = document.createElement('h3');
      sttTitle.textContent = 'STT (음성 텍스트)';
      const sttPre = document.createElement('pre');
      sttPre.style.background = '#f4f6f8';
      sttPre.style.padding = '12px';
      sttPre.style.borderRadius = '6px';
      sttPre.style.maxHeight = '240px';
      sttPre.style.overflow = 'auto';
      sttPre.textContent = data.stt_snippet || '(발화 없음)';
      sttSection.appendChild(sttTitle);
      sttSection.appendChild(sttPre);

      // 상세 리포트 섹션
      if (data.detailed_report && data.detailed_report.report) {
        const rep = data.detailed_report.report;
        const repSection = document.createElement('div');
        repSection.style.marginTop = '16px';
        const repTitle = document.createElement('h3');
        repTitle.textContent = '상세 리포트';
        const repPre = document.createElement('pre');
        repPre.style.background = '#f9fafb';
        repPre.style.padding = '12px';
        repPre.style.borderRadius = '6px';
        repPre.style.maxHeight = '300px';
        repPre.style.overflow = 'auto';
        repPre.textContent = JSON.stringify(rep, null, 2);
        repSection.appendChild(repTitle);
        repSection.appendChild(repPre);
        container.appendChild(repSection);
      }

      // 타임라인 / 간단한 시각화
      const timelineSection = document.createElement('div');
      timelineSection.style.marginTop = '16px';
      const timelineTitle = document.createElement('h3');
      timelineTitle.textContent = '간단 타임라인';
      const timelineCanvas = document.createElement('canvas');
      timelineCanvas.width = 800;
      timelineCanvas.height = 100;
      timelineCanvas.style.width = '100%';
      timelineCanvas.style.border = '1px solid #e6e9ee';
      timelineCanvas.style.borderRadius = '6px';
      timelineSection.appendChild(timelineTitle);
      timelineSection.appendChild(timelineCanvas);

      // 내용 조합
      container.appendChild(header);
      container.appendChild(summary);
      container.appendChild(sttSection);
      container.appendChild(timelineSection);
      panel.appendChild(container);
      document.body.appendChild(panel);

      // 간단한 타임라인 그리기 (프레임 수 기반)
      try {
        const ctx = timelineCanvas.getContext('2d');
        ctx.clearRect(0, 0, timelineCanvas.width, timelineCanvas.height);
        const frames = data.frames_count || 0;
        const maxFrames = Math.max(frames, 60);
        const barWidth = Math.max(4, (timelineCanvas.width / maxFrames) * Math.min(frames, maxFrames));
        ctx.fillStyle = '#4caf50';
        ctx.fillRect(0, timelineCanvas.height / 4, barWidth, timelineCanvas.height / 2);
        ctx.fillStyle = '#000';
        ctx.fillText(`프레임: ${frames}`, 10, 14);
      } catch (e) { console.warn('타임라인 렌더링 실패', e); }

      // 서버가 수락하고 최종 분석을 보냈으므로 로컬 자원 정리
      try { camera.stop(); } catch (e) { /* noop */ }
      try {
        clearInterval(recordingInterval);
        if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
        if (audioStream) audioStream.getTracks().forEach(t => t.stop());
      } catch (e) { console.warn('로컬 정리 오류', e); }

      statusDiv.textContent = '⏹️ 측정 중지됨';
    }

    // 결과 다운로드 유틸
    function downloadReport(data) {
      const report = {
        emotion: data.emotion,
        frames_count: data.frames_count,
        timestamp: data.timestamp,
        stt_snippet: data.stt_snippet,
        detailed_report: data.detailed_report || null
      };
      const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `analysis_${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // 페이지를 떠날 때 Interval 정리
    window.onbeforeunload = () => {
      clearInterval(recordingInterval);
      if (mediaRecorder && mediaRecorder.stream) {
        mediaRecorder.stream.getTracks().forEach(track => track.stop());
      }
    };
  </script>
   
</body>

</html>