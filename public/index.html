<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <title>BeMore - Emotion Analyzer Demo</title>
  <style>
    video,
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      transform: scaleX(-1);
    }

    #status {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px;
      border-radius: 8px;
      font-family: sans-serif;
      z-index: 10;
      max-width: 400px;
    }

    #controls {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px;
      border-radius: 8px;
      font-family: sans-serif;
      z-index: 10;
    }

    button {
      margin: 5px;
      padding: 10px 15px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      font-size: 14px;
    }

    button:hover {
      opacity: 0.8;
    }

    .btn-pause {
      background: #ff9800;
      color: white;
    }

    .btn-resume {
      background: #4caf50;
      color: white;
    }

    .btn-end {
      background: #f44336;
      color: white;
    }
  </style>
</head>

<body>
  <div id="status">
    <div>ğŸ¥ ì´ˆê¸°í™” ì¤‘...</div>
    <div id="session-info"></div>
    <div id="emotion-info"></div>
  </div>

  <div id="controls">
    <button class="btn-pause" onclick="pauseSession()">â¸ï¸ ì¼ì‹œì •ì§€</button>
    <button class="btn-resume" onclick="resumeSession()">â–¶ï¸ ì¬ê°œ</button>
    <button class="btn-end" onclick="endSession()">â¹ï¸ ì¢…ë£Œ</button>
  </div>

  <video id="input_video" autoplay playsinline></video>
  <canvas id="output_canvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

  <script>
    const statusDiv = document.getElementById("status");
    const sessionInfo = document.getElementById("session-info");
    const emotionInfo = document.getElementById("emotion-info");
    const videoElement = document.getElementById("input_video");
    const canvasElement = document.getElementById("output_canvas");
    const canvasCtx = canvasElement.getContext("2d");

    // ====== ì£¼ìš” ëœë“œë§ˆí¬ ì¸ë±ìŠ¤ (468ê°œ â†’ 68ê°œ ì¤‘ê°„ ì •ë°€ë„) ======
    // CBT ì¸ì§€ ì™œê³¡ íƒì§€ì— ìµœì í™”ëœ 68ê°œ í¬ì¸íŠ¸
    const KEY_LANDMARKS = {
      // ëˆˆ ì˜ì—­ (20ê°œ) - ëˆˆ ëœ¨ê¸°, ëˆˆê°€ ì£¼ë¦„ (Duchenne marker)
      eyes: [
        33, 133, 160, 144, 158, 153, 145, 159, 246, 163,  // ì™¼ìª½ ëˆˆ
        362, 263, 387, 373, 385, 380, 374, 386, 466, 390  // ì˜¤ë¥¸ìª½ ëˆˆ
      ],

      // ëˆˆì¹ ì˜ì—­ (10ê°œ) - AU1, AU2, AU4 (ìŠ¬í””, ë¶„ë…¸, ê±±ì •)
      eyebrows: [
        70, 63, 105, 66, 107,   // ì™¼ìª½ ëˆˆì¹
        300, 293, 334, 296, 336 // ì˜¤ë¥¸ìª½ ëˆˆì¹
      ],

      // ì… ì˜ì—­ (20ê°œ) - AU12, AU15, AU17, AU20 (í–‰ë³µ, ìŠ¬í””, ë¶„ë…¸)
      mouth: [
        61, 291, 0, 17, 37, 39, 40, 185, 409, 267,
        269, 270, 78, 308, 324, 318, 402, 317, 14, 87
      ],

      // ì½” ì˜ì—­ (8ê°œ) - AU9 (ì½” ì£¼ë¦„, í˜ì˜¤ ê°ì •)
      nose: [1, 2, 98, 327, 4, 5, 195, 197],

      // ì–¼êµ´ ìœ¤ê³½ (10ê°œ) - ì–¼êµ´ ë°©í–¥, ê°ë„
      contour: [10, 338, 297, 332, 284, 251, 389, 356, 454, 234]
    };

    // ëœë“œë§ˆí¬ ì••ì¶• í•¨ìˆ˜ (85% ëŒ€ì—­í­ ì ˆê°, ì •í™•ë„ 90%)
    function compressLandmarks(landmarks) {
      const face = landmarks[0];
      const compressed = {
        eyes: [],
        eyebrows: [],
        mouth: [],
        nose: [],
        contour: []
      };

      // ê° ì˜ì—­ë³„ë¡œ ì¢Œí‘œ ì¶”ì¶œ
      for (const [region, indices] of Object.entries(KEY_LANDMARKS)) {
        compressed[region] = indices.map(index => ({
          x: face[index].x,
          y: face[index].y,
          z: face[index].z
        }));
      }

      return compressed;
    }

    // ====== ì„¸ì…˜ ê´€ë¦¬ ======
    let sessionId = null;
    let landmarksWs = null;
    let voiceWs = null;
    let sessionWs = null;

    // ì„¸ì…˜ ì‹œì‘
    async function startSession() {
      try {
        const response = await fetch('/api/session/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            userId: 'demo_user_001',
            counselorId: 'demo_counselor_001'
          })
        });

        const result = await response.json();
        if (!result.success) {
          throw new Error(result.error.message);
        }

        sessionId = result.data.sessionId;
        sessionInfo.innerHTML = `<b>ì„¸ì…˜ ID:</b> ${sessionId}<br><b>ìƒíƒœ:</b> active`;

        // WebSocket 3ì±„ë„ ì—°ê²°
        connectWebSockets(result.data.wsUrls);

        return sessionId;
      } catch (error) {
        console.error('ì„¸ì…˜ ì‹œì‘ ì˜¤ë¥˜:', error);
        statusDiv.textContent = `âŒ ì„¸ì…˜ ì‹œì‘ ì‹¤íŒ¨: ${error.message}`;
        throw error;
      }
    }

    // WebSocket 3ì±„ë„ ì—°ê²°
    function connectWebSockets(wsUrls) {
      // 1. Landmarks ì±„ë„
      landmarksWs = new WebSocket(wsUrls.landmarks);
      landmarksWs.onopen = () => console.log('âœ… Landmarks ì±„ë„ ì—°ê²°');
      landmarksWs.onmessage = (event) => {
        const message = JSON.parse(event.data);
        if (message.type === 'emotion_update') {
          emotionInfo.innerHTML = `<b>ğŸ˜ƒ ê°ì •:</b> ${message.data.emotion}<br><b>í”„ë ˆì„:</b> ${message.data.frameCount}`;
        }
      };

      // 2. Voice ì±„ë„
      voiceWs = new WebSocket(wsUrls.voice);
      voiceWs.onopen = () => console.log('âœ… Voice ì±„ë„ ì—°ê²°');
      voiceWs.onmessage = (event) => {
        const message = JSON.parse(event.data);
        if (message.type === 'stt_received') {
          console.log('âœ… STT ìˆ˜ì‹  í™•ì¸');
        }
      };

      // 3. Session ì±„ë„
      sessionWs = new WebSocket(wsUrls.session);
      sessionWs.onopen = () => console.log('âœ… Session ì±„ë„ ì—°ê²°');
      sessionWs.onmessage = (event) => {
        const message = JSON.parse(event.data);
        console.log('Session ë©”ì‹œì§€:', message);

        if (message.type === 'status_update') {
          sessionInfo.innerHTML = `<b>ì„¸ì…˜ ID:</b> ${sessionId}<br><b>ìƒíƒœ:</b> ${message.data.status}<br><b>ê°ì • ìˆ˜:</b> ${message.data.emotionCount}`;
        }
      };
    }

    // ì„¸ì…˜ ì œì–´ í•¨ìˆ˜ë“¤
    async function pauseSession() {
      if (!sessionId) return;
      const res = await fetch(`/api/session/${sessionId}/pause`, { method: 'POST' });
      const data = await res.json();
      console.log('â¸ï¸ ì¼ì‹œì •ì§€:', data);
    }

    async function resumeSession() {
      if (!sessionId) return;
      const res = await fetch(`/api/session/${sessionId}/resume`, { method: 'POST' });
      const data = await res.json();
      console.log('â–¶ï¸ ì¬ê°œ:', data);
    }

    async function endSession() {
      if (!sessionId) return;


      // 1. STT ì „ì†¡ ë°˜ë³µ ì¢…ë£Œ
      if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
      }

      // 2. MediaRecorder ì •ì§€
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }

      // 3. ë§ˆì´í¬ ìŠ¤íŠ¸ë¦¼ íŠ¸ë™ ì¤‘ì§€
      if (audioStream) {
        audioStream.getTracks().forEach(track => track.stop());
        audioStream = null;
      }



      const res = await fetch(`/api/session/${sessionId}/end`, { method: 'POST' });
      const data = await res.json();
      console.log('âœ… ì¢…ë£Œ:', data);

      // WebSocket ì—°ê²° ì¢…ë£Œ
      if (landmarksWs) landmarksWs.close();
      if (voiceWs) voiceWs.close();
      if (sessionWs) sessionWs.close();
    }

    // ====== MediaPipe FaceMesh ì„¤ì • ======
    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });

    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    let frameCount = 0;
    faceMesh.onResults((results) => {
      canvasElement.width = videoElement.videoWidth;
      canvasElement.height = videoElement.videoHeight;
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      if (results.multiFaceLandmarks) {
        // ì „ì²´ ëœë“œë§ˆí¬ ì‹œê°í™”
        for (const landmarks of results.multiFaceLandmarks) {
          for (const point of landmarks) {
            const x = point.x * canvasElement.width;
            const y = point.y * canvasElement.height;
            canvasCtx.beginPath();
            canvasCtx.arc(x, y, 1.5, 0, 2 * Math.PI);
            canvasCtx.fillStyle = "red";
            canvasCtx.fill();
          }
        }

        // ì••ì¶•ëœ ë°ì´í„° ì „ì†¡ (30fps â†’ 10fpsë¡œ ì „ì†¡)
        frameCount++;
        if (frameCount % 3 === 0 && landmarksWs && landmarksWs.readyState === WebSocket.OPEN) {
          const compressed = compressLandmarks(results.multiFaceLandmarks);
          landmarksWs.send(JSON.stringify({
            type: 'landmarks',
            data: compressed
          }));
        }
      }
    });

    // ====== ì¹´ë©”ë¼ ì‹œì‘ ======
    const camera = new Camera(videoElement, {
      onFrame: async () => await faceMesh.send({ image: videoElement }),
      width: 640,
      height: 480
    });

    // ====== ë§ˆì´í¬ ë…¹ìŒ ë° STT ì „ì†¡ ======
    let mediaRecorder;
    let audioChunks = [];
    let audioStream;
    let recordingInterval;

    const initAndStartRecorder = (stream) => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }

      audioChunks = [];
      mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm; codecs=opus" });

      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) {
          audioChunks.push(e.data);
        }
      };

      mediaRecorder.start();
    };

    async function startMicRecording() {
      audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      initAndStartRecorder(audioStream);

      recordingInterval = setInterval(async () => {
        if (mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
        } else {
          initAndStartRecorder(audioStream);
          return;
        }

        if (audioChunks.length === 0) {
          initAndStartRecorder(audioStream);
          return;
        }

        const blob = new Blob(audioChunks, { type: "audio/webm; codecs=opus" });

        if (blob.size < 500) {
          initAndStartRecorder(audioStream);
          return;
        }

        const formData = new FormData();
        formData.append("audio", blob, `speech_${Date.now()}.webm`);
        initAndStartRecorder(audioStream);

        try {
          const res = await fetch("/api/stt/transcribe", {
            method: "POST",
            body: formData
          });
          const data = await res.json();
          console.log("ğŸ—£ï¸ STT ê²°ê³¼:", data.text);

          // Voice ì±„ë„ë¡œ STT í…ìŠ¤íŠ¸ ì „ì†¡
          if (voiceWs && voiceWs.readyState === WebSocket.OPEN && data.text) {
            voiceWs.send(JSON.stringify({
              type: 'stt_text',
              data: { text: data.text }
            }));
          }
        } catch (err) {
          console.error("STT ì—…ë¡œë“œ ì‹¤íŒ¨:", err);
        }
      }, 5000);

      statusDiv.textContent = "ğŸ¤ ìŒì„± ë…¹ìŒ ì¤‘ + ì–¼êµ´ ì¶”ì  ì¤‘";
    }

    // ====== ì•± ì´ˆê¸°í™” ======
    async function initApp() {
      try {
        // 1. ì„¸ì…˜ ì‹œì‘
        await startSession();

        // 2. ì¹´ë©”ë¼ ì‹œì‘
        camera.start();

        // 3. ë§ˆì´í¬ ì‹œì‘
        await startMicRecording();

        statusDiv.innerHTML = '<div>âœ… ëª¨ë“  ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ</div>';
      } catch (error) {
        statusDiv.innerHTML = `<div>âŒ ì´ˆê¸°í™” ì‹¤íŒ¨: ${error.message}</div>`;
      }
    }

    // ì•± ì‹œì‘
    initApp();

    // í˜ì´ì§€ë¥¼ ë– ë‚  ë•Œ ì •ë¦¬
    window.onbeforeunload = () => {
      clearInterval(recordingInterval);
      if (mediaRecorder && mediaRecorder.stream) {
        mediaRecorder.stream.getTracks().forEach(track => track.stop());
      }
      endSession();
    };
  </script>
</body>

</html>