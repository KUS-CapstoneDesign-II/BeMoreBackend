#!/usr/bin/env node

/**
 * Schema Validation Script
 *
 * Purpose: Validate that Sequelize models match schema/init.sql
 * Usage: node scripts/validate-schema.js
 *
 * Prevents schema-model mismatches like the refreshToken issue (2025-01-12)
 */

const fs = require('fs');
const path = require('path');

// ANSI colors for terminal output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  bold: '\x1b[1m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

// Model field definitions
const modelFields = {
  User: {
    file: 'models/User.js',
    fields: [
      'id',           // Auto-generated by Sequelize
      'username',
      'email',
      'password',
      'refreshToken', // Added 2025-01-12
      'profileImage',
      'createdAt',    // Auto-generated by Sequelize
      'updatedAt'     // Auto-generated by Sequelize
    ]
  },
  Session: {
    file: 'models/Session.js',
    fields: [
      'id',
      'sessionId',
      'userId',
      'counselorId',
      'status',
      'startedAt',
      'endedAt',
      'duration',
      'counters',
      'emotionsData',
      'createdAt',
      'updatedAt'
    ]
  }
  // Add more models as needed
};

// Parse schema/init.sql for table definitions
function parseSchemaSQL() {
  const schemaPath = path.join(__dirname, '..', 'schema', 'init.sql');

  if (!fs.existsSync(schemaPath)) {
    log('‚ùå schema/init.sql not found!', 'red');
    process.exit(1);
  }

  const schemaSQL = fs.readFileSync(schemaPath, 'utf8');
  const tables = {};

  // Extract users table
  const usersMatch = schemaSQL.match(/CREATE TABLE "users" \(([\s\S]*?)\);/);
  if (usersMatch) {
    const columnsText = usersMatch[1];
    const columns = columnsText
      .split(',')
      .map(line => {
        const match = line.trim().match(/"(\w+)"/);
        return match ? match[1] : null;
      })
      .filter(col => col && !col.startsWith('--'));

    tables.users = columns;
  }

  // Extract sessions table
  const sessionsMatch = schemaSQL.match(/CREATE TABLE "sessions" \(([\s\S]*?)\);/);
  if (sessionsMatch) {
    const columnsText = sessionsMatch[1];
    const columns = columnsText
      .split(',')
      .map(line => {
        const match = line.trim().match(/"(\w+)"/);
        return match ? match[1] : null;
      })
      .filter(col => col && !col.startsWith('--'));

    tables.sessions = columns;
  }

  return tables;
}

// Main validation
function validateSchema() {
  log('\n' + '='.repeat(60), 'blue');
  log('Schema Validation Tool', 'bold');
  log('='.repeat(60) + '\n', 'blue');

  const schemaTables = parseSchemaSQL();
  let hasErrors = false;
  let hasWarnings = false;

  // Validate User model
  if (modelFields.User) {
    log('üìã Validating User model...', 'blue');

    const schemaColumns = schemaTables.users || [];
    const modelFieldsList = modelFields.User.fields;

    // Check for missing columns in schema
    const missingInSchema = modelFieldsList.filter(field => !schemaColumns.includes(field));

    if (missingInSchema.length > 0) {
      log(`  ‚ùå Schema missing columns: ${missingInSchema.join(', ')}`, 'red');
      hasErrors = true;
    } else {
      log('  ‚úÖ All model fields exist in schema', 'green');
    }

    // Check for extra columns in schema
    const extraInSchema = schemaColumns.filter(col => !modelFieldsList.includes(col));

    if (extraInSchema.length > 0) {
      log(`  ‚ö†Ô∏è  Schema has extra columns: ${extraInSchema.join(', ')}`, 'yellow');
      hasWarnings = true;
    }
  }

  // Validate Session model
  if (modelFields.Session && schemaTables.sessions) {
    log('\nüìã Validating Session model...', 'blue');

    const schemaColumns = schemaTables.sessions || [];
    const modelFieldsList = modelFields.Session.fields;

    const missingInSchema = modelFieldsList.filter(field => !schemaColumns.includes(field));

    if (missingInSchema.length > 0) {
      log(`  ‚ùå Schema missing columns: ${missingInSchema.join(', ')}`, 'red');
      hasErrors = true;
    } else {
      log('  ‚úÖ All model fields exist in schema', 'green');
    }

    const extraInSchema = schemaColumns.filter(col => !modelFieldsList.includes(col));

    if (extraInSchema.length > 0) {
      log(`  ‚ö†Ô∏è  Schema has extra columns: ${extraInSchema.join(', ')}`, 'yellow');
      hasWarnings = true;
    }
  }

  // Summary
  log('\n' + '='.repeat(60), 'blue');

  if (hasErrors) {
    log('‚ùå VALIDATION FAILED - Schema-Model mismatch detected!', 'red');
    log('\nAction Required:', 'yellow');
    log('  1. Update schema/init.sql to match model definitions', 'yellow');
    log('  2. OR update models to match schema', 'yellow');
    log('  3. Ensure production database is updated accordingly\n', 'yellow');
    process.exit(1);
  } else if (hasWarnings) {
    log('‚ö†Ô∏è  VALIDATION PASSED WITH WARNINGS', 'yellow');
    log('Schema has extra columns not defined in models (may be intentional)\n', 'yellow');
    process.exit(0);
  } else {
    log('‚úÖ VALIDATION PASSED - Schema matches models perfectly!', 'green');
    log('No schema-model mismatches detected.\n', 'green');
    process.exit(0);
  }
}

// Run validation
validateSchema();
